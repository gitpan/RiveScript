.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RiveScript 3"
.TH RiveScript 3 "2008-03-16" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RiveScript \- Rendering Intelligence Very Easily
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use RiveScript;
\&
\&  # Create a new RiveScript interpreter.
\&  my $rs = new RiveScript;
\&
\&  # Load a directory of replies.
\&  $rs\->loadDirectory ("./replies");
\&
\&  # Load another file.
\&  $rs\->loadFile ("./more_replies.rs");
\&
\&  # Stream in some RiveScript code.
\&  $rs\->stream (q~
\&    + hello bot
\&    \- Hello, human.
\&  ~);
\&
\&  # Sort all the loaded replies.
\&  $rs\->sortReplies;
\&
\&  # Chat with the bot.
\&  while (1) {
\&    print "You> ";
\&    chomp (my $msg = <STDIN>);
\&    my $reply = $rs\->reply (\*(Aqlocaluser\*(Aq,$msg);
\&    print "Bot> $reply\en";
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
RiveScript is a simple trigger/response language primarily used for the creation
of chatting robots. It's designed to have an easy-to-learn syntax but provide a
lot of power and flexibility. For more information, visit
http://www.rivescript.com/
.SH "METHODS"
.IX Header "METHODS"
.Sh "\s-1GENERAL\s0"
.IX Subsection "GENERAL"
.IP "new (\s-1ARGS\s0)" 4
.IX Item "new (ARGS)"
Create a new instance of a RiveScript interpreter. The instance will become its
own \*(L"chatterbot,\*(R" with its own set of responses and user variables. You can pass
in any global variables here. The two standard variables are:
.Sp
.Vb 4
\&  debug \- Turns on debug mode (a LOT of information will be printed to the
\&          terminal!). Default is 0 (disabled).
\&  depth \- Determines the recursion depth limit when following a trail of replies
\&          that point to other replies. Default is 50.
.Ve
.Sp
It's recommended that if you set any other global variables that you do so by
calling \f(CW\*(C`setGlobal\*(C'\fR or defining it within the RiveScript code. This will avoid
the possibility of overriding reserved globals. Currently, these variable names
are reserved:
.Sp
.Vb 3
\&  topics  sorted   sortsthat  thats
\&  arrays  subs     person     client
\&  bot     objects  reserved
.Ve
.Sh "\s-1LOADING\s0 \s-1AND\s0 \s-1PARSING\s0"
.IX Subsection "LOADING AND PARSING"
.IP "loadDirectory ($PATH[,@EXTS])" 4
.IX Item "loadDirectory ($PATH[,@EXTS])"
Load a directory full of RiveScript documents. \f(CW$PATH\fR must be a path to a
directory. \f(CW@EXTS\fR is optionally an array containing file extensions, including
the dot. By default \f(CW@EXTS\fR is \f(CW\*(C`(\*(Aq.rs\*(Aq)\*(C'\fR.
.Sp
Returns true on success, false on failure.
.IP "loadFile ($PATH)" 4
.IX Item "loadFile ($PATH)"
Load a single RiveScript document. \f(CW$PATH\fR should be the path to a valid
RiveScript file. Returns true on success; false otherwise.
.IP "stream ($CODE)" 4
.IX Item "stream ($CODE)"
Stream RiveScript code directly into the module. This is for providing \s-1RS\s0 code
from within the Perl script instead of from an external file. Returns true on
success.
.IP "sortReplies" 4
.IX Item "sortReplies"
Call this method after loading replies to create an internal sort buffer. This
is necessary for trigger matching purposes. If you fail to call this method
yourself, RiveScript will call it once when you request a reply. However, it
will complain loudly about it.
.Sh "\s-1CONFIGURATION\s0"
.IX Subsection "CONFIGURATION"
.ie n .IP "setSubroutine ($NAME, $CODEREF)" 4
.el .IP "setSubroutine ($NAME, \f(CW$CODEREF\fR)" 4
.IX Item "setSubroutine ($NAME, $CODEREF)"
Manually create a RiveScript object (a dynamic bit of Perl code that can be
provoked in a RiveScript response). \f(CW$NAME\fR should be a single-word,
alphanumeric string. \f(CW$CODEREF\fR should be a pointer to a subroutine or an
anonymous sub.
.IP "setGlobal (%DATA)" 4
.IX Item "setGlobal (%DATA)"
Set one or more global variables, in hash form, where the keys are the variable
names and the values are their value. This subroutine will make sure that you
don't override any reserved global variables, and warn if that happens.
.Sp
This is equivalent to \f(CW\*(C`! global\*(C'\fR in RiveScript code.
.IP "setVariable (%DATA)" 4
.IX Item "setVariable (%DATA)"
Set one or more bot variables (things that describe your bot's personality).
.Sp
This is equivalent to \f(CW\*(C`! var\*(C'\fR in RiveScript code.
.IP "setSubstitution (%DATA)" 4
.IX Item "setSubstitution (%DATA)"
Set one or more substitution patterns. The keys should be the original word, and
the value should be the word to substitute with it.
.Sp
.Vb 4
\&  $rs\->setSubstitution (
\&    q{what\*(Aqs}  => \*(Aqwhat is\*(Aq,
\&    q{what\*(Aqre} => \*(Aqwhat are\*(Aq,
\&  );
.Ve
.Sp
This is equivalent to \f(CW\*(C`! sub\*(C'\fR in RiveScript code.
.IP "setPerson (%DATA)" 4
.IX Item "setPerson (%DATA)"
Set a person substitution. This is equivalent to \f(CW\*(C`! person\*(C'\fR in RiveScript code.
.IP "setUservar ($USER,%DATA)" 4
.IX Item "setUservar ($USER,%DATA)"
Set a variable for a user. \f(CW$USER\fR should be their User \s-1ID\s0, and \f(CW%DATA\fR is a
hash containing variable/value pairs.
.Sp
This is like \f(CW\*(C`<set>\*(C'\fR for a specific user.
.IP "getUservars ([$USER])" 4
.IX Item "getUservars ([$USER])"
Get all the variables about a user. If a username is provided, returns a hash
\&\fBreference\fR containing that user's information. Else, a hash reference of all
the users and their information is returned.
.Sp
This is like \f(CW\*(C`<get>\*(C'\fR for a specific user or for all users.
.IP "clearUservars ([$USER])" 4
.IX Item "clearUservars ([$USER])"
Clears all variables about \f(CW$USER\fR. If no \f(CW$USER\fR is provided, clears all
variables about all users.
.Sh "\s-1INTERACTION\s0"
.IX Subsection "INTERACTION"
.IP "reply ($USER,$MESSAGE)" 4
.IX Item "reply ($USER,$MESSAGE)"
Fetch a response to \f(CW$MESSAGE\fR from user \f(CW$USER\fR. RiveScript will take care of
lowercasing, running substitutions, and removing punctuation from the message.
.Sp
Returns a response from the RiveScript brain.
.Sh "\s-1INTERNAL\s0"
.IX Subsection "INTERNAL"
.IP "debug ($MESSAGE) *Internal" 4
.IX Item "debug ($MESSAGE) *Internal"
Prints a debug message to the terminal. Called from within in debug mode.
.IP "issue ($MESSAGE) *Internal" 4
.IX Item "issue ($MESSAGE) *Internal"
Called internally to report an issue (similar to a warning). If debug mode is
active, it will print the issue to \s-1STDOUT\s0 with a # sign prepended. Otherwise,
the issue is sent to \s-1STDERR\s0 via \f(CW\*(C`warn\*(C'\fR.
.ie n .IP "parse ($FILENAME, $CODE) *Internal" 4
.el .IP "parse ($FILENAME, \f(CW$CODE\fR) *Internal" 4
.IX Item "parse ($FILENAME, $CODE) *Internal"
This method is called internally to parse a file or streamed RiveScript code.
\&\f(CW$FILENAME\fR is only there so it can keep internal track of files and line
numbers, in case syntax errors appear.
.IP "_getreply ($USER,$MSG,%TAGS) *Internal" 4
.IX Item "_getreply ($USER,$MSG,%TAGS) *Internal"
\&\fBDo \s-1NOT\s0 call this method yourself.\fR This method assumes a few things about the
user's input that is taken care of by \f(CW\*(C`reply()\*(C'\fR. There is no reason to call
this method manually.
.IP "_reply_regexp ($USER,$TRIGGER) *Internal" 4
.IX Item "_reply_regexp ($USER,$TRIGGER) *Internal"
This method takes a raw trigger \f(CW$TRIGGER\fR and formats it for a matching
attempt in a regular expression. It removes \f(CW\*(C`{weight}\*(C'\fR tags, processes arrays,
processes bot variables and other tags, and returns something ready for the
regular expression engine.
.IP "processTags ($USER,$MSG,$REPLY,$STARS,$BOTSTARS) *Internal" 4
.IX Item "processTags ($USER,$MSG,$REPLY,$STARS,$BOTSTARS) *Internal"
Process tags in the bot's response. \f(CW$USER\fR and \f(CW$MSG\fR are the values
originally passed to the reply engine. \f(CW$REPLY\fR is the bot's raw response.
\&\f(CW$STARS\fR and \f(CW$BOTSTARS\fR are array references containing any wildcards matched
in a trigger or \f(CW%Previous\fR command, respectively. Returns a reply with all the
tags processed.
.IP "_formatMessage ($STRING) *Internal" 4
.IX Item "_formatMessage ($STRING) *Internal"
Formats a message to prepare it for reply matching. Lowercases the string, runs
substitutions, and sanitizes what's left.
.IP "_stringUtil ($TYPE,$STRING) *Internal" 4
.IX Item "_stringUtil ($TYPE,$STRING) *Internal"
Runs string modifiers on \f(CW$STRING\fR (uppercase, lowercase, sentence, formal).
.IP "_personSub ($STRING) *Internal" 4
.IX Item "_personSub ($STRING) *Internal"
Runs person substitutions on \f(CW$STRING\fR.
.SH "RIVESCRIPT"
.IX Header "RIVESCRIPT"
This interpreter tries its best to follow RiveScript standards. Currently it
supports RiveScript 2.0 documents. A current copy of the RiveScript working
draft is included with this package: see RiveScript::WD.
.SH "ERROR MESSAGES"
.IX Header "ERROR MESSAGES"
Most of the Perl warnings that the module will emit are self-explanatory, and
when parsing RiveScript files, file names and line numbers will be given. This
section of the manpage instead outlines error strings that may turn up in
responses to the bot's queries.
.Sh "\s-1ERR:\s0 Deep Recursion Detected!"
.IX Subsection "ERR: Deep Recursion Detected!"
The deep recursion depth limit has been reached (a response redirected to a
different trigger, which redirected somewhere else, etc.).
.PP
How to fix: override the global variable \f(CW\*(C`depth\*(C'\fR. This can be done via
\&\f(CW\*(C`setGlobal\*(C'\fR or in the RiveScript code:
.PP
.Vb 1
\&  ! global depth = 100
.Ve
.Sh "\s-1ERR:\s0 No Reply Matched"
.IX Subsection "ERR: No Reply Matched"
No match was found for the client's message.
.PP
How to fix: create a catch-all trigger of just \f(CW\*(C`*\*(C'\fR.
.PP
.Vb 2
\&  + *
\&  \- I don\*(Aqt know how to reply to that.
.Ve
.Sh "\s-1ERR:\s0 No Reply Found"
.IX Subsection "ERR: No Reply Found"
A match to the client's message was found, but no response to it was found. This
might mean you had a set of conditionals after it, and no \f(CW\*(C`\-Reply\*(C'\fR to fall back
on, and every conditional returned false.
.PP
How to fix: make sure you have at least one \f(CW\*(C`\-Reply\*(C'\fR to every \f(CW\*(C`+Trigger\*(C'\fR, even
if you don't expect that the \f(CW\*(C`\-Reply\*(C'\fR will ever be used.
.ie n .Sh "[\s-1ERR:\s0 Can't Modify Non-Numeric Variable $var]"
.el .Sh "[\s-1ERR:\s0 Can't Modify Non-Numeric Variable \f(CW$var\fP]"
.IX Subsection "[ERR: Can't Modify Non-Numeric Variable $var]"
You called a math tag on a variable, and the current value of the variable
contains something that isn't a number.
.PP
How to fix: verify that the variable you're working with is a number. If
necessary, reset the variable via \f(CW\*(C`<set>\*(C'\fR.
.ie n .Sh "[\s-1ERR:\s0 Math Can't ""add"" Non-Numeric Value $value]"
.el .Sh "[\s-1ERR:\s0 Math Can't ``add'' Non-Numeric Value \f(CW$value\fP]"
.IX Subsection "[ERR: Math Can't add Non-Numeric Value $value]"
(\*(L"add\*(R" may also be sub, mult, or div). You tried to run a math function on a
variable, but the value you used wasn't a number.
.PP
How to fix: verify that you're adding, subtracting, multiplying, or dividing
using numbers.
.Sh "[\s-1ERR:\s0 Can't Divide By Zero]"
.IX Subsection "[ERR: Can't Divide By Zero]"
A \f(CW\*(C`<div>\*(C'\fR tag was found that attempted to divide a variable by zero.
.PP
How to fix: make sure your division isn't dividing by zero. If you're using a
variable to provide the divisor, validate that the variable isn't zero by using
a conditional.
.PP
.Vb 2
\&  * <get divisor> == 0 => The divisor is zero so I can\*(Aqt do that.
\&  \- <div myvar=<get divisor>>I divided the variable by <get divisor>.
.Ve
.Sh "[\s-1ERR:\s0 Object Not Found]"
.IX Subsection "[ERR: Object Not Found]"
RiveScript attempted to call an object that doesn't exist. This may be because a
syntax error in the object prevented Perl from evaluating it, or the object was
written in a different programming language.
.PP
How to fix: verify that the called object was loaded properly. You will receive
notifications on the terminal if the object failed to load for any reason.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
RiveScript::WD \- A current snapshot of the Working Draft that
defines the standards of RiveScript.
.PP
<http://www.rivescript.com/> \- The official homepage of RiveScript.
.SH "CHANGES"
.IX Header "CHANGES"
.Vb 2
\&  Version 1.12
\&  \- Initial beta release for a RiveScript 2.00 parser.
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 1
\&  Casey Kirsle, http://www.cuvou.com/
.Ve
.SH "KEYWORDS"
.IX Header "KEYWORDS"
bot, chatbot, chatterbot, chatter bot, reply, replies, script, aiml, alpha
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
.Vb 2
\&  RiveScript \- Rendering Intelligence Very Easily
\&  Copyright (C) 2008  Casey Kirsle
\&
\&  This program is free software; you can redistribute it and/or modify
\&  it under the terms of the GNU General Public License as published by
\&  the Free Software Foundation; either version 2 of the License, or
\&  (at your option) any later version.
\&
\&  This program is distributed in the hope that it will be useful,
\&  but WITHOUT ANY WARRANTY; without even the implied warranty of
\&  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
\&  GNU General Public License for more details.
\&
\&  You should have received a copy of the GNU General Public License
\&  along with this program; if not, write to the Free Software
\&  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111\-1307  USA
.Ve
